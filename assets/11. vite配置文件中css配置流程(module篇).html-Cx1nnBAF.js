import{_ as s,c as t,o as l,a as e}from"./app-CxrMoykp.js";const n={},o=e("h1",{id:"vite-config-js中css配置-modules篇",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#vite-config-js中css配置-modules篇"},[e("span",null,"vite.config.js中css配置（modules篇）")])],-1),a=e("p",null,"在vite.config.js中我们通过css属性去控制真个vite对于css的处理行为",-1),i=e("ul",null,[e("li",null,"localConvention: 修改生成的配置对象的key的展示形式(驼峰还是中划线形式)"),e("li",null,"scopeBehaviour: 配置当前的模块化行为是模块化还是全局化 (有hash就是开启了模块化的一个标志, 因为他可以保证产生不同的hash值来控制我们的样式类名不被覆盖)"),e("li",null,"generateScopedName: 生成的类名的规则(可以配置为函数, 也可以配置成字符串规则: https://github.com/webpack/loader-utils#interpolatename)"),e("li",null,"hashPrefix: 生成hash会根据你的类名 + 一些其他的字符串(文件名 + 他内部随机生成一个字符串)去进行生成, 如果你想要你生成hash更加的独特一点, 你可以配置hashPrefix, 你配置的这个字符串会参与到最终的hash生成, （hash: 只要你的字符串有一个字不一样, 那么生成的hash就完全不一样, 但是只要你的字符串完全一样, 生成的hash就会一样）"),e("li",null,"globalModulePaths: 代表你不想参与到css模块化的路径")],-1),c=[o,a,i];function h(_,r){return l(),t("div",null,c)}const m=s(n,[["render",h],["__file","11. vite配置文件中css配置流程(module篇).html.vue"]]),u=JSON.parse('{"path":"/frontend/vite/11.%20vite%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%ADcss%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B(module%E7%AF%87).html","title":"vite.config.js中css配置（modules篇）","lang":"zh","frontmatter":{},"headers":[],"git":{"updatedTime":1721029030000,"contributors":[{"name":"linannan","email":"linannan@prosnav.com","commits":1}]},"filePathRelative":"frontend/vite/11. vite配置文件中css配置流程(module篇).md"}');export{m as comp,u as data};
