import{_ as n,c as s,o as a,b as e}from"./app-CgltcQVY.js";const p={},i=e(`<h1 id="入门篇" tabindex="-1"><a class="header-anchor" href="#入门篇"><span>入门篇</span></a></h1><h2 id="创建并运行-npm-script-命令" tabindex="-1"><a class="header-anchor" href="#创建并运行-npm-script-命令"><span>创建并运行 npm script 命令</span></a></h2><h3 id="npm-init" tabindex="-1"><a class="header-anchor" href="#npm-init"><span>npm init</span></a></h3><p>npm 为我们提供了快速创建 package.json 文件的命令 npm init，执行该命令会问几个基本问题，如包名称、版本号、作者信息、入口文件、仓库地址、许可协议等，多数问题已经提供了默认值，你可以在问题后敲回车接受默认值。</p><p>或者你可以使用 <code>npm init -f</code>（意指 --force，或者使用 --yes）告诉 npm 直接跳过参数问答环节，快速生成 package.json.</p><p>初始化 package.json 时的字段默认值是可以自己配置的:</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"><span class="token function">npm</span> config <span class="token builtin class-name">set</span> init.author.email <span class="token string">&quot;xxx@gmail.com&quot;</span></span>
<span class="line"><span class="token function">npm</span> config <span class="token builtin class-name">set</span> init.author.name <span class="token string">&quot;xxx&quot;</span></span>
<span class="line"><span class="token function">npm</span> config <span class="token builtin class-name">set</span> init.author.url <span class="token string">&quot;http://github.com/xxx&quot;</span></span>
<span class="line"><span class="token function">npm</span> config <span class="token builtin class-name">set</span> init.license <span class="token string">&quot;MIT&quot;</span></span>
<span class="line"><span class="token function">npm</span> config <span class="token builtin class-name">set</span> init.version <span class="token string">&quot;0.1.0&quot;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="用-npm-run-执行任意命令" tabindex="-1"><a class="header-anchor" href="#用-npm-run-执行任意命令"><span>用 npm run 执行任意命令</span></a></h3><p>作为 npm 内置的核心功能之一，npm run 实际上是 npm run-script 命令的简写。当我们运行 npm run xxx 时，基本步骤如下：</p><p>1、从 package.json 文件中读取 scripts 对象里面的全部配置；</p><p>2、以传给 npm run 的第一个参数作为键，本例中为 xxx，在 scripts 对象里面获取对应的值作为接下来要执行的命令，如果没找到直接报错；</p><p>3、在系统默认的 shell 中执行上述命令，系统默认 shell 通常是 bash，windows 环境下可能略有不同。</p><p>如果不带任何参数执行 npm run，它会列出可执行的所有命令。</p><p>如果运行 npm run eslint，npm 会在 shell 中运行 eslint **.js。 有没有好奇过上面的 eslint 命令是从哪里来的？其实，npm 在执行指定 script 之前会把 node_modules/.bin 加到环境变量 $PATH 的前面，这意味着任何内含可执行文件的 npm 依赖都可以在 npm script 中直接调用，换句话说，你不需要在 npm script 中加上可执行文件的完整路径。比如 ./node_modules/.bin/eslint **.js。</p><h2 id="运行多个-npm-script-的各种姿势" tabindex="-1"><a class="header-anchor" href="#运行多个-npm-script-的各种姿势"><span>运行多个 npm script 的各种姿势</span></a></h2><p>前端项目通常会包括多个 npm script，对多个命令进行编排是很自然的需求，有时候需要将多个命令串行，即脚本遵循严格的执行顺序；有时候则需要让它们并行来提高速度，比如不相互阻塞的 npm script。社区中也有比 npm 内置的多命令运行机制更好用的解决方案：npm-run-all</p><h3 id="让多个-npm-script-串行" tabindex="-1"><a class="header-anchor" href="#让多个-npm-script-串行"><span>让多个 npm script 串行</span></a></h3><p>只需要用 &amp;&amp; 符号把多条 npm script 按先后顺序串起来即可</p><p>需要注意的是，串行执行的时候如果前序命令失败（通常进程退出码非0），后续全部命令都会终止</p><h3 id="让多个-npm-script-并行" tabindex="-1"><a class="header-anchor" href="#让多个-npm-script-并行"><span>让多个 npm script 并行</span></a></h3><p>在严格串行的情况下，我们必须要确保代码中没有编码规范问题才能运行测试，在某些时候可能并不是我们想要的，因为我们真正需要的是，代码变更时同时给出测试结果和测试运行结果。这就需要把子命令的运行从串行改成并行，实现方式更简单，把连接多条命令的 <code>&amp;&amp;</code> 符号替换成 <code>&amp;</code></p><p>但 npm 内置支持的多条命令并行跟 js 里面同时发起多个异步请求非常类似，它只负责触发多条命令，而不管结果的收集，如果并行的命令执行时间差异非常大，就会发现有些结果在进程退出之后才输出。怎么解决这个问题呢？</p><p>答案也很简单，在命令的增加<code> &amp; wait</code></p><p>加上 wait 的额外好处是，如果我们在任何子命令中启动了长时间运行的进程，比如启用了 mocha 的 --watch配置，可以使用 ctrl + c来结束进程，如果没加的话，你就没办法直接结束启动到后台的进程。</p><h3 id="更好的管理方式" tabindex="-1"><a class="header-anchor" href="#更好的管理方式"><span>更好的管理方式</span></a></h3><p>可以使用 npm-run-all实现更轻量和简洁的多命令运行</p><p>npm-run-all是一个npm包，它允许你运行多个npm script，并且可以控制它们的执行顺序。</p><p><strong>npm-run-all安装：</strong></p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"><span class="token function">npm</span> i npm-run-all <span class="token parameter variable">-D</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>npm-run-all使用：</strong></p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line">// 修改前</span>
<span class="line"><span class="token string">&quot;scripts&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token string">&quot;test&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;npm run lint:js &amp; npm run lint:css &amp; npm run lint:json &amp; npm run lint:markdown &amp; mocha tests/ &amp; wait&quot;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line">// 修改后</span>
<span class="line"><span class="token string">&quot;scripts&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token string">&quot;test&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;npm-run-all lint:js lint:css lint:json lint:markdown mocha&quot;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>npm-run-all 还支持通配符匹配分组的 npm script，上面的脚本可以进一步简化成</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"><span class="token string">&quot;scripts&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token string">&quot;test&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;npm-run-all lint:* mocha&quot;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>并行执行的时候，我们并不需要在后面增加 &amp; wait，因为 npm-run-all 已经帮我们做了</p><h2 id="给-npm-script-传递参数和添加注释" tabindex="-1"><a class="header-anchor" href="#给-npm-script-传递参数和添加注释"><span>给 npm script 传递参数和添加注释</span></a></h2><h3 id="给-npm-script-传递参数" tabindex="-1"><a class="header-anchor" href="#给-npm-script-传递参数"><span>给 npm script 传递参数</span></a></h3><p>eslint 内置了代码风格自动修复模式，只需给它传入 --fix参数即可。但是如果调用其他的脚本传入参数时该如何呢？</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"></span>
<span class="line"><span class="token string">&quot;scripts&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token string">&quot;lint:js&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;eslint *.js&quot;</span>,</span>
<span class="line">  <span class="token string">&quot;lint:js:fix&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;npm run lint:js -- --fix&quot;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要格外注意 --fix参数前面的 --分隔符，意指要给 npm run lint:js实际指向的命令传递额外的参数。</p><h3 id="给-npm-script-添加注释" tabindex="-1"><a class="header-anchor" href="#给-npm-script-添加注释"><span>给 npm script 添加注释</span></a></h3><p>如果 package.json 中的 scripts 越来越多，或者出现复杂的编排命令，你可能需要给它们添加注释以保障代码可读性，但 json 天然是不支持添加注释的，下面是 2 种比较 trick 的方式。</p><p>第一种方式是，package.json 中可以增加 //为键的值，注释就可以写在对应的值里面，npm 会忽略这种键，比如，我们想要给 test 命令添加注释，按如下方式添加：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"></span>
<span class="line"><span class="token string">&quot;scripts&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token string">&quot;//&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;运行所有代码检查和单元测试&quot;</span>,</span>
<span class="line">  <span class="token string">&quot;test&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;npm-run-all --parallel lint:* mocha&quot;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式的明显不足是，npm run 列出来的命令列表不能把注释和实际命令对应上，如果你声明了多个，npm run 只会列出最后那个</p><p>另外一种方式是直接在 script 声明中做手脚，因为命令的本质是 shell 命令（适用于 linux 平台），我们可以在命令前面加上注释，具体做法如下：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"></span>
<span class="line"><span class="token string">&quot;scripts&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token string">&quot;test&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;# 运行所有代码检查和单元测试 <span class="token entity" title="\\n">\\n</span>    npm-run-all --parallel lint:* mocha&quot;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意注释后面的换行符 \\n 和多余的空格。</strong> 换行符是用于将注释和命令分隔开，这样命令就相当于微型的 shell 脚本，多余的空格是为了控制缩进，也可以用制表符 \\t替代。这种做法能让 npm run 列出来的命令更美观，但是 scripts 声明阅读起来不那么整齐美观。</p><p>上面两种方式都有明显的缺陷，个人建议的更优方案还是把复杂的命令剥离到单独的文件中管理，在单独的文件中可以自由给它添加注释</p><h3 id="调整-npm-script-运行时日志输出" tabindex="-1"><a class="header-anchor" href="#调整-npm-script-运行时日志输出"><span>调整 npm script 运行时日志输出</span></a></h3><ul><li>默认日志输出级别</li></ul><p>即不加任何日志控制参数得到的输出，可能是你最常用的，能看到执行的命令、命令执行的结果。</p><ul><li>显示尽可能少的有用信息</li></ul><p>结合其他工具调用 npm script 的时候比较有用，需要使用 --loglevel silent，或者 --silent，或者更简单的 -s来控制</p><ul><li>显示尽可能多的运行时状态</li></ul><p>排查脚本问题的时候比较有用，需要使用 --loglevel verbose，或者 --verbose，或者更简单的 -d来控制</p><h2 id="监听文件变化并自动运行-npm-script" tabindex="-1"><a class="header-anchor" href="#监听文件变化并自动运行-npm-script"><span>监听文件变化并自动运行 npm script</span></a></h2><h3 id="单元测试自动化" tabindex="-1"><a class="header-anchor" href="#单元测试自动化"><span>单元测试自动化</span></a></h3><p>mocha 本身支持 --watch参数，即在代码变化时自动重跑所有的测试，我们只需要在 scripts 对象中新增一条命令即可</p><h3 id="代码检查自动化" tabindex="-1"><a class="header-anchor" href="#代码检查自动化"><span>代码检查自动化</span></a></h3><p>我们使用的代码检查工具 stylelint、eslint、jsonlint不全支持 watch 模式，这里我们需要借助 onchange 工具包来实现，onchange 可以方便的让我们在文件被修改、添加、删除时运行需要的命令。</p><p>使用如下命令安装 onchange 到项目依赖中：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"><span class="token function">npm</span> i onchange <span class="token parameter variable">-D</span></span>
<span class="line"><span class="token comment"># npm install onchange --save-dev</span></span>
<span class="line"><span class="token comment"># yarn add onchange -D</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>添加 watch:lint 和 watch 两个子命令：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="line"><span class="token string">&quot;watch&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;npm-run-all --parallel watch:*&quot;</span>,</span>
<span class="line"><span class="token string">&quot;watch:lint&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;onchange -i <span class="token entity" title="\\&quot;">\\&quot;</span>**/*.js<span class="token entity" title="\\&quot;">\\&quot;</span> <span class="token entity" title="\\&quot;">\\&quot;</span>**/*.less<span class="token entity" title="\\&quot;">\\&quot;</span> -- npm run lint&quot;</span>,</span>
<span class="line"><span class="token string">&quot;watch:test&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;npm t -- --watch&quot;</span>,</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="实战篇" tabindex="-1"><a class="header-anchor" href="#实战篇"><span>实战篇</span></a></h1>`,65),t=[i];function l(c,r){return a(),s("div",null,t)}const u=n(p,[["render",l],["__file","用npmscript打造超溜的前端工作流.html.vue"]]),m=JSON.parse('{"path":"/tools/npm/%E7%94%A8npmscript%E6%89%93%E9%80%A0%E8%B6%85%E6%BA%9C%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%81.html","title":"入门篇","lang":"zh","frontmatter":{},"headers":[{"level":2,"title":"创建并运行 npm script 命令","slug":"创建并运行-npm-script-命令","link":"#创建并运行-npm-script-命令","children":[{"level":3,"title":"npm init","slug":"npm-init","link":"#npm-init","children":[]},{"level":3,"title":"用 npm run 执行任意命令","slug":"用-npm-run-执行任意命令","link":"#用-npm-run-执行任意命令","children":[]}]},{"level":2,"title":"运行多个 npm script 的各种姿势","slug":"运行多个-npm-script-的各种姿势","link":"#运行多个-npm-script-的各种姿势","children":[{"level":3,"title":"让多个 npm script 串行","slug":"让多个-npm-script-串行","link":"#让多个-npm-script-串行","children":[]},{"level":3,"title":"让多个 npm script 并行","slug":"让多个-npm-script-并行","link":"#让多个-npm-script-并行","children":[]},{"level":3,"title":"更好的管理方式","slug":"更好的管理方式","link":"#更好的管理方式","children":[]}]},{"level":2,"title":"给 npm script 传递参数和添加注释","slug":"给-npm-script-传递参数和添加注释","link":"#给-npm-script-传递参数和添加注释","children":[{"level":3,"title":"给 npm script 传递参数","slug":"给-npm-script-传递参数","link":"#给-npm-script-传递参数","children":[]},{"level":3,"title":"给 npm script 添加注释","slug":"给-npm-script-添加注释","link":"#给-npm-script-添加注释","children":[]},{"level":3,"title":"调整 npm script 运行时日志输出","slug":"调整-npm-script-运行时日志输出","link":"#调整-npm-script-运行时日志输出","children":[]}]},{"level":2,"title":"监听文件变化并自动运行 npm script","slug":"监听文件变化并自动运行-npm-script","link":"#监听文件变化并自动运行-npm-script","children":[{"level":3,"title":"单元测试自动化","slug":"单元测试自动化","link":"#单元测试自动化","children":[]},{"level":3,"title":"代码检查自动化","slug":"代码检查自动化","link":"#代码检查自动化","children":[]}]}],"git":{"updatedTime":1721817285000,"contributors":[{"name":"linannan","email":"linannan@prosnav.com","commits":1}]},"filePathRelative":"tools/npm/用npmscript打造超溜的前端工作流.md"}');export{u as comp,m as data};
